<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace:映射文件的命名空间，规范是映射文件的全路径-->
<!--作用:是一个路径，用来查找、下面的id-->
<mapper namespace="com.hp.dao.PersonDao"><!--命名空间-->
<resultMap id="BaseResultMap" type="com.hp.util.Person">


    <id column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="gender" property="gender"/>
    <result column="birthday" property="birthday"/>
    <result column="address" property="address"/>
    <result column="score" property="score"/>



</resultMap>
    <sql id="allColumn" >
      id ,name, gender, birthday ,address ,score
    </sql>

    <sql id="birthdayColumn" >
      id ,name, gender,  address ,score
    </sql>

    <select id="selectAll" resultMap="BaseResultMap">
        select * from person
    </select>
    <select id="selectPersonBySex" resultMap="BaseResultMap" parameterType="int">
        select  <include refid="birthdayColumn"/>  from person where gender=#{gender}
    </select>

    <select id="selectPersonCount" resultType="long">
        select count(*) from person
    </select>
  <!--  当前端传来多个参数的时候 要看这几个参数是否是同一个类中属性（这个是单表）如果是可以用这个属性做参数
    如果不是同一个类中的（这个是多表） 那么可以 手写一个参数的实体类（DTO）或者使用map做参数-->

    <select id="selectPersonByParmterCount01" resultType="long" parameterType="com.hp.util.Person">
        select count(*) from person where gender=#{gender} and score>#{score}
    </select>

   <!-- 查询性别是2 且生日大于2020-09-07的人有哪些？-->
    <select id="selectPersonByParmterCount02"  parameterType="map" resultMap="BaseResultMap">
       <![CDATA[  select * from person where gender=#{gender} and birthday < #{birthday}]]>
    </select>
    <!--查询最高分数的人-->

   <!-- <select id="selectPersonMax"  parameterType="int" resultMap="BaseResultMap">
        select * from person order by score=#{score} desc limit 1;
    </select>
    <select id="selectMaxScore"  resultType="int">
        select Max(score) from person
    </select>-->
<!--子查询-->
    <select id="selectPersonMax" resultMap="BaseResultMap">
       select * from person where score= (select Max(score) from person)
    </select>

    <select id="selectAvgScore"  resultType="com.hp.util.dto.PersonDTO">
        select gender,avg (score) avgScore from person Group by gender;
    </select>

    <select id="selectAvgScore1"  parameterType="int" resultType="com.hp.util.dto.PersonDTO">
        select gender,avg (score) avgScore from person Group by gender having avg(score)> #{score};
    </select>

    <select id="selectAvgScore2"  resultType="map" parameterType="int">
        select gender,avg (score) avgScore from person Group by gender having avg(score)> #{score};
    </select>
<!--第一种方式-->
    <select id="selectPersonByLike" resultMap="BaseResultMap"  parameterType="String">
/*使用$去拼接，sql编译的时候没有？ 不安全 容易被sql注入*/
        select * from person where name like '${name}%'
    </select>
<!--第二种方式 使用sql的concat的连接 可以被编译的-->
    <select id="selectPersonByLike2" resultMap="BaseResultMap"  parameterType="String">
/*可以被编译的*/
        select * from person where name like concat ('%',#{name},'%')
    </select>
<!--第三种方式-->
    <select id="selectPersonByLike3" resultMap="BaseResultMap"  parameterType="String">

        select * from person where name like "%"#{name}"%"
    </select>



    <!--增加-->
   <!-- 场景:学生多 班级1  当我 张三 李四  王五
    selectKey  一般多表 级联插入的时候 需要获取刚刚插入的数据的主键id的时候 用到的
    keyProperty  指的是主键的id
    order  指的是自增的主键 是数据插入后诞生的 还是插入前诞生的  mysql after ,oracle before
    resultType  指的是 主键id的数据类型，一般int 分布式是String 雪花算法
    select LAST_INSERT_ID() 查询最后插入的主键id-->
    <insert id="insertPerson" parameterType="com.hp.util.Person">
        <selectKey keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
    insert into person (id,name,gender,birthday,address,score) values (null,#{name},#{gender},#{birthday},#{address},#{score})
    </insert>
    <!--/////////////////////////////////////////////////-->
    <!--删除一条数据-->
<delete id="deletePersonById" parameterType="int">
    delete from person where id= #{id}
</delete>

    <!--动态sql 之 动态查询-->
    <!--动态sql 有 9个  where 1，删除第一个 and 2.代替原始sql 中的where  where常和if搭配-->
       <!-- where 里需要 把 方法里的 参数（map, 实体类）的属性写全-->
         <!--if的注意事项  test="gender"是值得 实体类中的属性， 驼峰的-->
    <select id="dontTaiSelect" resultMap="BaseResultMap" parameterType="com.hp.util.Person">
        select * from  person p
              <where>
                  <if test="id !=null and id != '' ">
                      p.id= #{id}
                  </if>

                  <if test="name !=null and name != '' ">
                     and p.name= #{name}
                  </if>

                  <if test="gender !=null and gender != '' ">
                     and p.gender= #{gender}
                  </if>

                  <if test="birthday !=null and birthday != '' ">
                     and p.birthday= #{birthday}
                  </if>

                  <if test="address !=null and address != '' ">
                     and p.address= #{address}
                  </if>

                  <if test="score !=null and score != '' ">
                     and p.score > #{score}
                  </if>
              </where>
    </select>
  <!--  动态修改 update person set xx=xx where id=?-->
    <update id="dongTaiUpdate"  parameterType="com.hp.util.Person">
        update  person p
        <set>


            <if test="name !=null and name != '' ">
                 p.name= #{name},
            </if>

            <if test="gender !=null and gender != '' ">
                 p.gender= #{gender},
            </if>

            <if test="birthday !=null ">
                 p.birthday= #{birthday},
            </if>

            <if test="address !=null and address != '' ">
                 p.address= #{address},
            </if>

            <if test="score !=null and score != '' ">
                 p.score = #{score}
            </if>
        </set>
        where
        p.id=#{id}
    </update>
    <!--批量删除-->
 <!--   delete from person where id in(1,2,3)-->
    <delete id="piLiangDel" parameterType="map">
        delete from person  where id in
          <foreach collection="ids" open="(" item="id"  separator="," close=")" index="index">
              #{id}
          </foreach>
    </delete>
</mapper>